<h1> Punteros </h1>

- [Introducción](#introducción)
  - [Punteros y Memoria](#punteros-y-memoria)
  - [Ventajas](#ventajas)
  - [Desventajas](#desventajas)
  - [Declaración de punteros](#declaración-de-punteros)
  - [Operaciones de dirección](#operaciones-de-dirección)
  - [Desreferenciación de un puntero mediante el operador de indirección](#desreferenciación-de-un-puntero-mediante-el-operador-de-indirección)
  - [Operaciones con punteros](#operaciones-con-punteros)
    - [Aritmética de punteros](#aritmética-de-punteros)
  - [Uso de los punteros](#uso-de-los-punteros)
  - [Concepto de `NULL`](#concepto-de-null)
  - [Concepto de `nullptr`](#concepto-de-nullptr)
- [Manejo de la memoría dinámica en C/C++](#manejo-de-la-memoría-dinámica-en-cc)
  - [Funciones para la asignación de memoria](#funciones-para-la-asignación-de-memoria)
  - [New](#new)
  - [Delete](#delete)
- [Memoria Stack and Heap](#memoria-stack-and-heap)
  - [Memoría Stack](#memoría-stack)
  - [Memoría Heap](#memoría-heap)
- [Pointers and Arrays](#pointers-and-arrays)
  - [Resumen de Array](#resumen-de-array)
    - [Array unidimensional](#array-unidimensional)
    - [Array bidimensional](#array-bidimensional)
    - [Array multidimensional](#array-multidimensional)
  - [Notación de punteros y arrays](#notación-de-punteros-y-arrays)
  - [Diferencia entre array y pointer](#diferencia-entre-array-y-pointer)
  - [Crear un array unidimensional](#crear-un-array-unidimensional)
  - [Array de punteros](#array-de-punteros)
    - [Explicación de la notación de punteros](#explicación-de-la-notación-de-punteros)
  - [Punteros y arrays multidimensionales](#punteros-y-arrays-multidimensionales)
- [Pointers and Strings](#pointers-and-strings)
- [Pointers and Structures](#pointers-and-structures)
- [Puntero `void`](#puntero-void)

# Introducción 

La definición más elementar de un puntero, es una variable, que puede almacenar
la dirección de una posición de memoria, y para poder comprender mejor esto debemos
de conocer primero como se gestiona la memoria en un programa en C++.

## Punteros y Memoria

Al momento de compilar un programa en C++, este trabaja con 3 tipos de memoria.

<h3> Estática/Global </h3>

Las variables declaradas estaticamente o globalmente, pertenecen al mismo
bloque de memoria; durando toda la ejecución del programa.
Siendo su diferencia, que se puede tener acceso a las variables globales en cualquier
momento y en cualquier función; en cambio, las estáticas se limitan a la función
que las define.

<h3> Automatica </h3>

Estas son las variables declaradas dentro de una función cuando esta es llamada;
por lo tanto su tiempo de ejecución también es el tiempo de ejecución de la función.

<h3> Dinámica </h3>

Espacio de la memoria de a la cual se puede asignar un puntero, donde este hace
referencia a la memoria, y existiendo hasta que uno la libere.

|            | Alcance                        | Tiempo de vida                               |
| ---------- | ------------------------------ | -------------------------------------------- |
| Global     | Todo el archivo                | Todo el tiempo de ejecución de la aplicación |
| Estático   | Cuando la función es declarada | Todo el tiempo de ejecución de la aplicación |
| Automática | Cuando la función es declarada | El tiempo de ejecución de la función         |
| Dinámica   | Determinada por los punteros   | Hasta que la memoria sea liberada            |

## Ventajas

Como los punteros son capaces de almacenar las direcciones de memoria, significa
que están más cerca del lenguaje máquina; logrando que el tiempo de compilación
sea más rápido, que otros operadores.

También, la representación de las `estructuras de datos` se pueden trabajar más
facilmente con los punteros.

## Desventajas

Una desventaja del uso de los punteros, es el uso de expresiones compactas, las 
cuales no suelen muy descriptivas de lo que se está realizando; asiendo que el programador
tenga que ir decifrando.

```CPP
char *names[] = {"Hello","Errant","Programmer"};
// Notación de punteros
std::cout << *(*(names+1)+2) << std::endl;
// Notación de array
std::cout << names[1][2] << std::endl;
```
Otras desventas que se presentan al momento de usar los punteros y no se tenga
un entendimiento correcto de su funcinamiento:

- Acceder a información más allá de sus límites.
- Hacer referencia a variables cuando ya no existan.
- Hacer referencia a memoria que anteriormente a sido liberada.
- Desreferenciar a un puntero antes de que se haya asignado memoria.
## Declaración de punteros

La declaración de un puntero es sencillo, solo se tiene definir el `tipo de variable`
que se desea tener como puntero seguido de un `*`.

```CPP
int num; // Variable
// Cualquiera de las siguientes formas es valida para declarar un puntero
int*ptr1;
int* ptr2;
int *ptr3;
int * ptr4;
```
> Un puntero, solo va a hacer referencia al mismo tipo que fue declarado en un principio

## Operaciones de dirección

El operador `&`, nos devuelve la dirección de memoria de una variable. Por lo tanto,
se utiliza para inicializar los punteros.

```CPP
int num = 0; // Variable
int *ptr = &num;

// Error compiler
int num = 0;
int *ptr;
ptr = num;
```
<img src="Img/punteros/imagen1.png">

> Recordar:
>
> Los punteros almacenan direcciones de memoria

Convertir un entero a un puntero:

```CPP
int num = 0;
int *ptr = &num;
ptr = (int *)num;
```

> Esto sirve para cualquier tipo de variable 

## Desreferenciación de un puntero mediante el operador de indirección

El operador de indirección `*`, este nos devuelve al valor al que apunta un puntero;
y es este proceso que se le conoce como referido o desreferenciar un puntero.

```CPP
int num = 5;
int *ptr = &num;

std::cout << "Su valor es: " << *ptr <<std::endl; // Visualizamos en pantaña 5
```

Este mismo procedimiento es que se utiliza, para hacer cambios a la variable a la
cual hace referencia.

```CPP
int num = 0;
int *ptr = &num;

ptr = 200;

std::cout << "La dirección de memoria es: " << &num << ", su valor es: " << num <<std::endl;
std::cout << "La dirección de memoria es: " << &ptr << ", su valor es: " << ptr <<std::endl;
```
## Operaciones con punteros

| Operador                 | Nombre                                                                 | Significado                                                    |
| ------------------------ | ---------------------------------------------------------------------- | -------------------------------------------------------------- |
| *                        |                                                                        | Usado para declarar punteros                                   |
| *                        | Dereferenciar                                                          | Usado para dereferenciar un puntero                            |
| ->                       | Point-to(apuntar a)                                                    | Acceder a campos de una estructura referenciada por un puntero |
| +                        | Adición                                                                | Usado para incrementar un puntero                              |
| -                        | Subtracción                                                            | Usado para decrementar un puntero                              |
| == !=                    | Igualdad y desiguladad                                                 | Comparar 2 punteros                                            |
| > <br> >= <br> < <br> <= | Menor que <br> menor o igual que <br> Mayor que <br> Mayor o igual que | Comparar 2 punteros                                            |
| (data type)              | Cast(caster o casteo)                                                  | Cambiar el tipo del puntero                                    |

### Aritmética de punteros

1. Añadir un entero a un puntero

Cuando se añade un entero a un puntero, lo que se hace es incrementar en `bits`
el tamaño de la dirección de memoria, es relación al tipo de la variable que se
este sumando.

```CPP
// Ejemplo 1
int vector[] = {2021,2022,2023};
int *ptr = vector;

std::cout << "Ptr: " << *ptr<<std::endl;
ptr += 1;
std::cout << "Ptr: " << *ptr<<std::endl;
ptr += 1;
std::cout << "Ptr: " << *ptr<<std::endl;
// Tambien podemos usar el sizeof() para indicar la cantidad a incrementar
// Ejemplo 2
int vector[] = {2021,2022,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033};
int *ptr = vector;
double a = 1;

std::cout << "Ptr: " << *ptr<<std::endl;
ptr += sizeof(double); //Otra forma ptr += sizeof(a);
std::cout << "Ptr: " << *ptr<<std::endl;
```

> Para los punteros de tipo `void`, es mejore revisarlo si su compilador lo acepta,
> no todos los compiladores lo permiten.

2. Sustraer un entero a un puntero

De forma similar, al restar un entereo a un puntero, este se decrementa en la
misma cantidad de `bits` del tipo de variable que se este rezando.

```CPP
// Ejemplo 1
int vector[] = {2021,2022,2023};
int *ptr = vector + 2;

std::cout << "Ptr: " << *ptr<<std::endl;
ptr--;
std::cout << "Ptr: " << *ptr<<std::endl;
ptr--;
std::cout << "Ptr: " << *ptr<<std::endl;
// Tambien podemos usar el sizeof() para indicar la cantidad a incrementar
// Ejemplo 2
int vector[] = {2021,2022,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033};
int *ptr = vector + 8;
std::cout << "Ptr: " << *ptr<<std::endl; 
ptr -= sizeof(double); //Otra forma ptr -= sizeof(a);
std::cout << "Ptr: " << *ptr<<std::endl;
```

3. Sustraer 2 punteros entre sí

Cuando se retar 2 punteros entre sí, en sí se están restando las direcciones de memoria
que tiene almacenada; No el valor de al cual hace referencia dicha dirección de memoria.

```CPP

int vector[] = {47,20,7};
int *p0 = vector;
int *p1 = vector + 1;
int *p2 = vector + 2;
std::cout << " P2 - P0 " << p2 - p0 << std::endl;
std::cout << " P2 - P1 " << p2 - p1 << std::endl;
std::cout << " P0 - P1 " << p0 - p1 << std::endl;
```

Para poder restar el valor al cual esa referencia la dirección de memoria que tiene
almacenanda, tenemoes que hacer dereferenciarlo.

```CPP
std::cout << " P2 - P0 " << *p2 - *p0 << std::endl;
```

4. Comparar punteros

Los mismo al comprar punteros, lo que se realiza es la comparación de las
direcciones de memoria que tengan almacenada, y para comparar el valor al cual
hace referencia dicha dirección, se tiene que dereferenciar, para obtener el
valor.

```CPP
int vector[] = {1,2,3,4,5,6,7};
int *p1 = vector;
int *p2 = vector + 1;

if(*p1 < *p2){ // 1 < 2
  // ...
}
```

<img src="Img/punteros/imagen2.png">

## Uso de los punteros

Tenemos 2 usos principales de los punteros:

- Nivel de indirección

Si diseamos apuntar a un puntero, este tiene que ser unicamente 1 nivel superior al que tenga
dicho puntero, al que deseamos apuntar.

Los niveles en los punteros están relacionados la cantidad de `*` al momento de ser
declarado:

```CPP
int a;    //Nivel 0
int *b    //Nivel 1
int **c;  //Nivel 2
int ***d; //Nivel 3
int ****e;//Nivel 4

b = &a;
c = &b;
d = &c;
// Error compiler
// d = &a;
```
## Concepto de `NULL`

El concepto de `NULL` para un puntero, es cuando este hace referencia a ningún valor.
La idea es que el puntero, apunte a un valor especial donde solo es igual a otro puntero
que también apunte a dicho valor.

La macro, para el puntero `NULL` es una constante entera convertida a un puntero void:

```CPP
#define NULL ((void *)0)
```
Ahora si bien se puede utilizar el `0` para representar el valor de `NULL`, este
puede genera confunsión; por lo que, no es recomendable usarlo.

```CPP
int num;
int *p = 0; // Pointer NULL

p = &num;
p = 0; // Referencia al valor de tipo int
```
Pero también se puede usar el `NULL`, como valor `0`.

```CPP
int num = NULL + 10;
std::cout << num << std::endl;
```

El compilador nos indicará que se esta usando el `NULL`, en una operación
aritmética.

> NULL used in arithmetic

## Concepto de `nullptr`

Como puede existe, errores al momento de trabajar con el valor de `NULL`, 
en C++ se implemento el **Null pointer constant**, funciona de forma similar al 
`NULL`, solo que este al ya no ser una macro, el compilador utilizará otras instrucciones
máquinas, para indicar que el puntero esta apuntado a la nada.

```CPP
char *pc = nullptr;  //OK 
int  *pi = nullptr;  //OK
bool   c = nullptr;  //OK. c is false
int    i = nullptr;  //error
```

# Manejo de la memoría dinámica en C/C++

En C/C++, al ser lenguajes de bajo nivel, podemos gestionar la memoria del computador
y como los punteros son quienes nos permite interactuar con esta; son ellos los que
más se benefician de poder manejar la memoría del computador.

Lo pasos más básicos del manejo la memoria en `C/C++` es:

- Usar `new` para asignar espacio de memoria.
- Usar la memoria para soportar aplicaciones.
- Liberar la memoria asignada con la función `delete`.

```CPP
int cant = 5;
int *ptr = new int;

char *pc = new char[6];

for(int i = 0; i < 6; i++){
  *pc[i] = 0;
}
```

Al momento de realizar la función `new` en el mismo puntero, la memoria
anteriormente asignada, no se libera, se queda en el `heap` de la memoria del programa,
por lo cual, esta memoria se va a ir almacenando y como dicha memoria no se puede
volver asignar a ninguna otra variables esta hace que se sobrecarga.

La memoria perdida, ya no puede volver a ser localizada porque no conocemos la 
dirección de memoria de la asignación anterior.

## Funciones para la asignación de memoria

En `C++` contamos con las siguientes funciones para la asignación de memoria:

| Función  | Descripción                             |
| -------- | --------------------------------------- |
| `new`    | Asigna la memoria en el *heap*          |
| `delete` | Libera la memoria asignada en el *heap* |

## New

La palabra clave `new`, nos permite asignar me memoria al puntero al cual hacemos referencia.

```CPP
// <type> <nombre> = new <type>(<value>)
int a = new int(5); 
std::cout << a << std::endl; // a = 5
// <type> <nombre> = new <type>[<value>]
int *ptr = new int[5];
```

Tanto si le asignamos un núevo valor, o como si le asignamos multiples valores,
está nueva memória será asignada en el `heap` de la memoría.

## Delete

La función `delete` nos ayuda a liberar la memoría asignada en el `heap` de la memoría RAM.

```CPP
// delete <nombre>;  si se asigno un único valor
delete a;
// delete[] <nombre>;  si se asigno varios valores
delete[] ptr;
ptr = nullptr;
```

> Se remocienda después de usar el delete, que el puntero apunte a `nullptr`.

# Memoria Stack and Heap

No voy a explicar el como funciona la memoría de un computador y todas las partes
que lo dividen; pero sí de las partes más importantes que están en relación con la
memoría `RAM` y los `punteros`:

- *Stack* 
- *Heap*
## Memoría Stack

Esta parte de la memoría es definida por nuestro sistema operativo cuando se
ejecuta un programa, por lo que, su espacio limitado y si en caso llegemos a 
sobre pasar dicho espacio estaremos en el problema conocido como *Stack Overflow*.

Es en esta memoría donde también se van almacenando las funciones y las variables
que la componen.

> No se abordará en esta parte el concepto de que es una función, solo tener
> en cuenta es que son partes del código que se puede llamar en cualquier momento.

Supongamos que tenemos definidas cierta función en el fichero `Foo`.
```CPP
#include <iostream>
#include "Foo"

int main(){
  int num;
  num = foo();
  std::cout << num << std::endl;
  int num2;
  num2 = foo2();
  std::cout << num2 << std::endl;
  return 0;
}
```

Graficamente el funcionamiento de la memoría `Stack`, se vería de la siguiente manera:

<img src = "Img/punteros/stack1.png">

1. Se ejecuta el programa, y se aloja en la memoría el función *main*

2. Se llama a la función *foo()*, por lo que se apila en la memoría, y se empieza a ejecutar

3. Una vez terminado, se elimina automaticamente de la memoría, y se retorna a la 
ejecución de la función main.

4. De la misma forma para la función *foo2()*

5. Se termina de ejecutar el programa, y *main()* también es eliminada de la memoría.

> Recordar que las variables asociadas a cierta función, solo van a funcionar dentro de la misma función
> no puede ser usada en otra función, para nuestro ejemplo la función *foo()* ni *foo2()*,
> pueden hacer uso de las variables de la función *main()*. 
## Memoría Heap

A diferencia de la memória `Stack`, la `Heap` no tiene un espacio determinado, sino
que va creciendo conforme vayamos necesitando; por lo que es muy usado para almacenar
strucutras con grandes porciones de datos.

Es justo en esta parte de la memoría, donde van a estar apuntado los punteros
que definamos; puesto que, solo podemos acceder a ella con los punteros.

Tener en consideración, que cuando se asigne memoría con `new` no se verá eliminada
en ningún momento, a menos que la eliminemos manualmente con la función `delete`.
Incluso si la función que donde fue asignada ya fue eliminada del `Stack`.

<img src = "Img/punteros/heap1.png">

Por lo tanto, siempre se va a tener cuidado con la asignación de memoría a un puntero;
porque si el puntero apunta a un nuevo valor, y no se liberó anteriormente
esa porción se quedará activa en la memoría y sin forma que podamos acceder a ella nuevamente.

```CPP
int *ptr = new int[5];// Se le asigna memoria
int num = 5;
ptr =  &num; // Ya perdimos la información de la memoría que se le asigno originalmente
```
> [!IMPORTANT]
> Si desean ver graficamente aquí una [página web](https://pythontutor.com/visualize.html#mode=edit)


# Pointers and Arrays

El array, es la estructura de datos más fundamental que existe en C/C++.

Los arrays y punteros son distintos, si bien podemos hacer uso de la notación
de los array en punteros, y trabajar los arrays como si fueran punteros, veremos
que esto es incorrecto, y cada uno tiene su propia notación.

## Resumen de Array

### Array unidimensional

Los array son estructura de datos, sencillas que nos permite almacenar datos
de un mismo tipo de valor, y si se ve desde la memoria, estos son almacenados
continuamente, sin ningún bit de separación; y podemos acceder a ellos con un index.


```CPP
// Sintaxis:
// <tipo-de-dato> nombre[CANTIDAD DE DATOS];
// Otra forma
//             0, 1, 2
int array[] = {10,20,30};
```

> Recordar: cualquier tipo de array empieza su `index` con *0*
 
### Array bidimensional

También contamos con matrices de multiples dimensiones, siendo la más común la
bidimensional; siendo representada por filas y columnas;


> C/C++ va a almacenar los arreglos dimensionales, donde primero van todos los valores
> de la pimera fila, y luego la siguiente, hasta que se acaben las filas
> 
> Al igual que no debemos de confundir un array con un puntero.
> Tampoco se tiene que confundir un array bidimensional con una matriz de punteros.

### Array multidimensional

Podemos tener array de multiples dimensiones, aunque estos no lleguen a ser muy
ususados.

```CPP
int arr3d[filas][columnas][profundidad] = {
  {{1,2,3,4},{5,6,7,8}},
  {{9,10,11,12},{13,14,15,16}},
  {{17,18,19,20},{21,22,23,24}}
};
// Almacenamiento:
/*
arr3d[0][0][1] = 1;
arr3d[0][0][2] = 2;
arr3d[0][0][3] = 3;
arr3d[0][0][4] = 4;
arr3d[0][1][0] = 5;
arr3d[0][1][1] = 6;
arr3d[0][1][2] = 7;
arr3d[0][1][3] = 8;
....
arr3d[2][1][3] = 24;
*/
```

## Notación de punteros y arrays

```CPP
int vector[5] = {1,2,3,4,5};
int *ptr = vector;

std::cout << "Notacion de array\n";
for (int i = 0; i < 5; i++){
  std::cout << vector[i];
}
std::cout << "\n";

std::cout << "Notacion de punteros\n";
for (int i = 0; i < 5; i++){
  std::cout << *(ptr + i);
}
std::cout << "\n";
```

> Nota: tener cuidado con la notación de los punteros porque nos podemos ir más
> alla de los límites del arreglo y estaríamos recogiendo la basura del sistema.

## Diferencia entre array y pointer

Las diferencia más clara la podemos encontrar en como el compilador ejecuta el código
máquina respecto a ambos.

- `array`: Generá código máquina que se mueve `i` posiciones desde la ubicación
del vector y usa su contenido
- `pointer`: Generá código máquina que incrementa la dirección de memoría del vecotr
en `i`, y usa el contenido en dicha dirección

> El resultado es el mismo, pero como lo trabaja el compilador es distinto

## Crear un array unidimensional

Para poder crear un array, se utilizará la función `new`.

```CPP
int *vector = new int[5];
```

<img src="Img/punteros/imagen3.png">

> No olvidar liberar la memoría asignada cuando ya no se necesite.


## Array de punteros

<!-- agregar imagen -->

```CPP
// Notación de array
int *arr[5];
for (int i = 0; i < 5; i++) {
   arr[i] = new int;
   *arr[i] = i + 1;
}

for (int i = 0; i < 5; i++) {
   std::cout << *arr[i] << " ";
}

// Notación de punteros
int *arr[5];
for(int i = 0; i < 5 , i++){
  *(arr + i) = new int;
  **(arr + i) = i + 1;
}

for(int i = 0; i < 5 , i++){
  std::cout << **(arr + i) << " ";
}
```
### Explicación de la notación de punteros

- `arr`: Es la dirección de memoría de la variable
- `arr + i`: Es la dirección de memoría, incrementado en i veces
- `*arr`: Es la dirección de memoría que tiene almacenado, o dicho de otro modo a la que apunta
- `**arr`: Es es valor de que tiene almacenado, la dirección de memoría almacenado por el puntero

## Punteros y arrays multidimensionales

Siguiendo la idea de lo explicado anteriormente, podemos hacer que un puntero del
array de punteros apunte array, asignandole memória dinámica.

Con punteros

```CPP
// Notación de punteros
int **matrix;
int value = 1,
filas = 2,
columnas = 5;
matrix = new int *[filas];
for (int i = 0; i < filas; i++) {
     *(matrix + i) = new int[columnas];
    for (int j = 0; j < columnas; j++) {
        *(*(matrix + i) + j) = value++;
    }
}

for (int i = 0; i <filas; i++){
  for(int j = 0 ; j < columnas; j++){
    std::cout << "Matrix[" << i << "][" << j << "] Address: " << (*(matrix + i) + j) << " Value: " <<  *(*(matrix + i) + j) << std::endl;
  }
}
/*
matrix[0][0] Address: 007B7F10 Value: 1
matrix[0][1] Address: 007B7F14 Value: 2
matrix[0][2] Address: 007B7F18 Value: 3
matrix[0][3] Address: 007B7F1C Value: 4
matrix[0][4] Address: 007B7F20 Value: 5
matrix[1][0] Address: 007B7F30 Value: 6
matrix[1][1] Address: 007B7F34 Value: 7
matrix[1][2] Address: 007B7F38 Value: 8
matrix[1][3] Address: 007B7F3C Value: 9
matrix[1][4] Address: 007B7F40 Value: 10
*/
```
Esto es similar, si hicieramos lo siguiente con los arreglos:

```CPP
// Notación de array
int matrix[2][5] ={
  {1,2,3,4,5},
  {6,7,8,9,10}
};

for (int i = 0; i <2; i++){
  for(int j = 0 ; j < 5; j++){
    std::cout << "matrix[" << i << "][" << j << "] Address: " << &matrix[i][j] << " Value: " << matrix[i][j] << std::endl;
  }
}
```

<img src="Img/punteros/imagen4.png">

> La ventaja, es que podemos modificar el arreglo de punteros, de acuerdo a lo solicitado
> por un usuario, en cambio con arreglo vamos a tener algo predefinido, que no se puede
> variar.

```CPP
// Para arreglo de tridimensional
int ***matrix3D;
int fil = 5, col = 5, profundidad = 2,value = 0;

matrix3D = new int**[fil];

for (int i = 0; i < fil; i++) {
   *(matrix3D + i) = new int*[col];
    for (int j = 0; j < col; j++) {
        *(*(matrix3D + i) + j) = new int[profundidad];
        for (int k = 0; k < profundidad; k++) {
            *(*(*(matrix3D + i) + j) + k) = value;
            value++;
        }
    }
}

for (int i = 0; i < fil; i++) {
    for (int j = 0; j < col; j++) {
        for (int k = 0; k < profundidad; k++) {
            std::cout << "matrix[" << i << "][" << j << "][" << k
            << "] Address: " << (*(*(matrix3D + i) + j) + k)
            << " Value: " << *(*(*(matrix3D + i) + j) + k) << std::endl;
        }
    }
}
/*
matrix[0][0][0] Address: 007B7AE8 Value: 1
matrix[0][0][1] Address: 007B7AEC Value: 2
matrix[0][1][0] Address: 007B7AF8 Value: 3
matrix[0][1][1] Address: 007B7AFC Value: 4
matrix[0][2][0] Address: 007B7B08 Value: 5
matrix[0][2][1] Address: 007B7B0C Value: 6
matrix[0][3][0] Address: 007B7B18 Value: 7
matrix[0][3][1] Address: 007B7B1C Value: 8
matrix[0][4][0] Address: 007B7B28 Value: 9
matrix[0][4][1] Address: 007B7B2C Value: 10
matrix[1][0][0] Address: 007B7B58 Value: 11
matrix[1][0][1] Address: 007B7B5C Value: 12
matrix[1][1][0] Address: 007B7B68 Value: 13
matrix[1][1][1] Address: 007B7B6C Value: 14
matrix[1][2][0] Address: 007B7B78 Value: 15
matrix[1][2][1] Address: 007B7B7C Value: 16
matrix[1][3][0] Address: 007B7B88 Value: 17
matrix[1][3][1] Address: 007B7B8C Value: 18
matrix[1][4][0] Address: 007B7B98 Value: 19
matrix[1][4][1] Address: 007B7B9C Value: 20
matrix[2][0][0] Address: 007B7BC8 Value: 21
matrix[2][0][1] Address: 007B7BCC Value: 22
matrix[2][1][0] Address: 007B7BD8 Value: 23
matrix[2][1][1] Address: 007B7BDC Value: 24
matrix[2][2][0] Address: 007B7BE8 Value: 25
matrix[2][2][1] Address: 007B7BEC Value: 26
matrix[2][3][0] Address: 007B7BF8 Value: 27
matrix[2][3][1] Address: 007B7BFC Value: 28
matrix[2][4][0] Address: 007B7C08 Value: 29
matrix[2][4][1] Address: 007B7C0C Value: 30
matrix[3][0][0] Address: 007B7C38 Value: 31
matrix[3][0][1] Address: 007B7C3C Value: 32
matrix[3][1][0] Address: 007BBF20 Value: 33
matrix[3][1][1] Address: 007BBF24 Value: 34
matrix[3][2][0] Address: 007B7E10 Value: 35
matrix[3][2][1] Address: 007B7E14 Value: 36
matrix[3][3][0] Address: 007B7D60 Value: 37
matrix[3][3][1] Address: 007B7D64 Value: 38
matrix[3][4][0] Address: 007B7D40 Value: 39
matrix[3][4][1] Address: 007B7D44 Value: 40
matrix[4][0][0] Address: 007B7DC0 Value: 41
matrix[4][0][1] Address: 007B7DC4 Value: 42
matrix[4][1][0] Address: 007B7E40 Value: 43
matrix[4][1][1] Address: 007B7E44 Value: 44
matrix[4][2][0] Address: 007B7CF0 Value: 45
matrix[4][2][1] Address: 007B7CF4 Value: 46
matrix[4][3][0] Address: 007B7DD0 Value: 47
matrix[4][3][1] Address: 007B7DD4 Value: 48
matrix[4][4][0] Address: 007B7D20 Value: 49
matrix[4][4][1] Address: 007B7D24 Value: 50
*/
```
Un problema con este tipo de asignación, es que la memoria no es continua,
en el sentido que la dirección de memoria usada por fila del array de punteros,
apunta a una sección distinta de la memoria del sistema. Pero se puede solucionar
si se trabaja con los punteors, de la siguiente manera:

```CPP
int filas = 2;
int columnas = 5;
int value = 1;
// creación de la matriz bidimensional.
int **matrix = new int*[filas];
matrix[0] = new int[filas * columnas];

for (int i = 1; i < filas; i++)
    matrix[i] = matrix[0] + i * columnas;

// asignación de valor
for (int i = 0; i < filas; i++) {
    for (int j = 0; j < columnas; j++) {
        *(*(matrix + i) + j) = value++;
    }
}
// impresión
for (int i = 0; i < filas; i++) {
    for (int j = 0; j < columnas; j++) {
        std::cout << "maxContinue[" << i << "][" << j << "] Address: " << (*(matrix + i) + j) << " Value: " << *(*(matrix + i) + j) << std::endl;
    }
}
/* output
maxContinue[0][0] Address: 00F6BF30 Value: 1
maxContinue[0][1] Address: 00F6BF34 Value: 2
maxContinue[0][2] Address: 00F6BF38 Value: 3
maxContinue[0][3] Address: 00F6BF3C Value: 4
maxContinue[0][4] Address: 00F6BF40 Value: 5
maxContinue[1][0] Address: 00F6BF44 Value: 6
maxContinue[1][1] Address: 00F6BF48 Value: 7
maxContinue[1][2] Address: 00F6BF4C Value: 8
maxContinue[1][3] Address: 00F6BF50 Value: 9
maxContinue[1][4] Address: 00F6BF54 Value: 10
*/
```

# Pointers and Strings

> [!IMPORTANT]
> Desde la versión de `C++98` se agregó el tipo de variable `string`, con el cual
> facilita el estar manejando string con punteros; pero por fines académicos se tuilizarán
> los punteros. Para más adelante en el curso si se permitirá su uso.
<!-- VERIFICAR A PARTIR DE QUE TEMA SE PERMITE LA REALIZACION DE ESTE TEMA-->

Los `strings` van a ser utilizados habitualmente para realizar operaciones con
cadenas de texto(array de tipo char), y con los punteros vamos a poder
asignar memoría dinámicamente y el paso de las cadenas a funciones
para su uso.







# Pointers and Structures

Con los `struct`, podemos mejorar la utilidad de colecciones como los Arrays.
Para recrear un array de entidades como un tipo de color con múltiples campos sin utilizar
una estructura.

```CPP
typedef struct _persona{
  char *Nombre;
  char *apellido;
  unsigned int edad;
} Persona;

// Declaración de la estructura
Persona persona;
// Declaración por medio de punteros
Persona *ptrpersona; // primera forma
ptrpersona = new Persona; // segunda forma
```

La diferencia entre las declaraciones, sería el método para poder acceder a los miembros del `struct`:

- Para la primera, se usaría la `dot notation`, el cual es usado para la selección directa de los miembros.
```CPP
persona.nombre = new char[strlen("Jesus") + 1];
strcpy(persona.nombre,"Jesus");
persona.edad = 23;
```

- Para la segunda, se usaría la [`pointst-to`](#operaciones-con-punteros).

```CPP
ptrpersona->nombre = new char[strlen("Jesus") + 1];
strcpy(ptrPpersona->nombre,"Jesus");
ptrPpersona->edad = 23;
```

La `structs`, son un tipo de variable, por lo que se le puede trabajar de la misma
forma que las demás variables que hemos visto, solo debemos de considerar la forma
en como accedemos a los miembros de la variable.


```CPP
// Declaración
typedef struct _structMatrix{
  int filas;
  int columnas;
  int **matrix;
}StructMatrix;

StructMatrix *ptrMatrixStruct;
ptrMatrixStruct = new StructMatrix;
ptrMatrixStruct->filas = 5;
ptrMatrixStruct->columnas = 5;
ptrMatrixStruct->matrix = new int *[ptrMatrixStruct->filas];
int value = 1;
for (int i = 0; i < ptrMatrixStruct->filas; i++) {
    *(ptrMatrixStruct->matrix + i) =  new int [ptrMatrixStruct->columnas];
    for (int j = 0; j < ptrMatrixStruct->columnas; j++) {
        *(*(ptrMatrixStruct->matrix + i) + j) = value++;
    }
}

for (int i = 0; i < ptrMatrixStruct->filas; i++) {
    for (int j = 0; j < ptrMatrixStruct->columnas; j++) {
        std::cout << "StructMatrix[" << i << "][" << j
        << "] Address: " << (*(ptrMatrixStruct->matrix + i) + j)
        << " Value: " << *(*(ptrMatrixStruct->matrix + i) + j) << std::endl;
    }
}
```

```bash
# Output
StructMatrix[0][0] Address: 01127EF0 Value: 1
StructMatrix[0][1] Address: 01127EF4 Value: 2
StructMatrix[0][2] Address: 01127EF8 Value: 3
StructMatrix[0][3] Address: 01127EFC Value: 4
StructMatrix[0][4] Address: 01127F00 Value: 5
StructMatrix[1][0] Address: 01127F10 Value: 6
StructMatrix[1][1] Address: 01127F14 Value: 7
StructMatrix[1][2] Address: 01127F18 Value: 8
StructMatrix[1][3] Address: 01127F1C Value: 9
StructMatrix[1][4] Address: 01127F20 Value: 10
StructMatrix[2][0] Address: 01127A98 Value: 11
StructMatrix[2][1] Address: 01127A9C Value: 12
StructMatrix[2][2] Address: 01127AA0 Value: 13
StructMatrix[2][3] Address: 01127AA4 Value: 14
StructMatrix[2][4] Address: 01127AA8 Value: 15
StructMatrix[3][0] Address: 01127AB8 Value: 16
StructMatrix[3][1] Address: 01127ABC Value: 17
StructMatrix[3][2] Address: 01127AC0 Value: 18
StructMatrix[3][3] Address: 01127AC4 Value: 19
StructMatrix[3][4] Address: 01127AC8 Value: 20
StructMatrix[4][0] Address: 01127AD8 Value: 21
StructMatrix[4][1] Address: 01127ADC Value: 22
StructMatrix[4][2] Address: 01127AE0 Value: 23
StructMatrix[4][3] Address: 01127AE4 Value: 24
StructMatrix[4][4] Address: 01127AE8 Value: 25
```

# Puntero `void`

<h1> AGREGAR INFORMACION</h1>

Sabemos que no existe los tipos de datos [`void`](../1Variables/variables.md/#void),
pero si los punteros de este tipo, donde a diferencia de los otros tipos de punteros,
que solo pueden se referenciados a otras variables del mismo tipo; el puntero `void`,
puede hacer referencia a cualquier tipo de variable.

Como un puntero void, puede apuntar a cualquier tipo de dato, no se le podría aplicar
la aritmética de puntero directamente, ya que el compilador no sabe a que tipo
de dato esta haciendo referencia dicho puntero.

Para poder hacer la referencia al dato que apunta este tipo de puntero, tenemos
que hacer un casteo.

```CPP
int a = 5;
void *ptrVoid;
int array[5] = {1,2,3,4,5};
ptrVoid = array;

ptrVoid = (int *)ptrVoid + 1; // Los compiladores no permite ptr++
ptrVoid = (int *)ptrVoid + 3; // Los compiladores no permite ptr += 3

std::cout << *(int *)ptrVoid;
```
